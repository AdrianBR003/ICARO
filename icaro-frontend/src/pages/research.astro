---
import BaseLayout from "@/layouts/BaseLayout.astro";
import TopUtility from "@/components/CCommon/TopUtility.astro";
import NavBar from "@/components/CCommon/NavBar.astro";
import Header from "@/components/CCommon/Header.astro";
import CTitle from "@/components/CCommon/TitlePages.astro";
import ResearchFilters from "@/components/CResearch/ResearchFilters.astro";
import ResearchList from "@/components/CResearch/ResearchList.astro";
import ResearchAddPublication from "@/components/CResearch/ResearchAddPublication.astro";
import "@/styles/index.css";

const API_BASE_URL = "http://localhost:8080";
let works = [];

// Obtener trabajos
try {
  const res = await fetch(`${API_BASE_URL}/api/works/all`);
  if (!res.ok) throw new Error(`Error HTTP: ${res.status}`);
  works = await res.json();

  works = works.map((work) => {
    const { type, ...cleanWork } = work;
    let tags = [];

    if (work.tags) {
      if (Array.isArray(work.tags)) {
        tags = work.tags
          .filter((t) => t !== null && t !== undefined)
          .map((t) => String(t).trim())
          .filter((t) => t.length > 0);
      } else if (typeof work.tags === "string") {
        tags = work.tags
          .split(",")
          .map((t) => t.trim())
          .filter((t) => t.length > 0);
      } else {
        tags = [String(work.tags).trim()].filter((t) => t.length > 0);
      }
    }

    return {
      ...cleanWork,
      tags: tags,
    };
  });
} catch (e) {
  console.error("Error al obtener trabajos:", e);
  works = [];
}

// Obtener nombres de proyectos
const projectIds = [
  ...new Set(works.map((work) => work.projectId).filter(Boolean)),
];

const projectNamesMap = new Map();
for (const projectId of projectIds) {
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/project-work/name/${projectId}`,
    );

    if (response.ok) {
      const projectName = await response.text();
      projectNamesMap.set(projectId, projectName);
    } else {
      projectNamesMap.set(projectId, "");
    }
  } catch (error) {
    projectNamesMap.set(projectId, "");
  }
}

const worksWithProjectNames = works.map((work) => {
  const projectName = work.projectId
    ? projectNamesMap.get(work.projectId) || ""
    : "";
  return {
    ...work,
    projectName: projectName,
  };
});

// Agrupar por a√±o
const groupsObj = {};
worksWithProjectNames.forEach((w) => {
  const year = w.projectDate?.slice(0, 4) || "Sin fecha";
  if (!groupsObj[year]) groupsObj[year] = [];
  groupsObj[year].push(w);
});

const noDate = groupsObj["Sin fecha"] || [];
delete groupsObj["Sin fecha"];
const researchGroups = Object.entries(groupsObj)
  .map(([year, items]) => ({ year, items }))
  .sort((a, b) => b.year.localeCompare(a.year, { numeric: true }));
if (noDate.length) researchGroups.push({ year: "Sin fecha", items: noDate });

const mostRecentYear = researchGroups[0]?.year || "all";

// Categor√≠as para filtros
const tagCategories = new Set();
const projectCategories = new Set();

worksWithProjectNames.forEach((work) => {
  work.tags.forEach((tag) => tagCategories.add(tag));
  if (work.projectName && work.projectName.trim() !== "") {
    projectCategories.add(work.projectName);
  }
});
---

<BaseLayout>
  <section class="max-w-full bg-white shadow-md rounded-lg">
    <TopUtility />
    <Header />
  </section>
  <section class="mt-10 max-w-full bg-white shadow-md">
    <NavBar />
  </section>

  <CTitle Title="Research" />

  <section class="max-w-4xl mx-auto px-4">
    <!-- Bot√≥n de agregar publicaci√≥n - se muestra/oculta din√°micamente -->
    <ResearchAddPublication />

    <ResearchFilters
      tagCategories={tagCategories}
      projectCategories={projectCategories}
      researchGroups={researchGroups}
      mostRecentYear={mostRecentYear}
    />

    <!-- Lista de investigaci√≥n - isAdmin se maneja din√°micamente -->
    <ResearchList researchGroups={researchGroups} />

    <div class="text-center mt-8">
      <button
        id="load-more"
        class="bg-[#1D293D] text-white px-4 py-2 rounded-md hover:shadow-[0_2px_10px_-2px_rgba(0,0,0,0.7)] transition-shadow"
        >Mostrar m√°s</button
      >
    </div>
  </section>

  <script is:inline>
    document.addEventListener("DOMContentLoaded", function () {
      console.log('üöÄ [RESEARCH] P√°gina iniciada');
      
      // ============= SISTEMA DE AUTENTICACI√ìN JWT =============
      
      // Helper para generar headers con token JWT
      function getAuthHeaders() {
        const token = localStorage.getItem('adminToken');
        
        const headers = {
          'Content-Type': 'application/json'
        };
        
        // Si existe token, a√±adir header Authorization con Bearer
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        }
        
        return headers;
      }
      
      // ============= GESTI√ìN DEL ESTADO ADMIN =============
      let currentAdminStatus = false;
      
      // Verificar estado admin con token JWT
      async function checkAdminStatus() {
        console.log('üîê [RESEARCH] Verificando estado admin...');
        
        try {
          const token = localStorage.getItem('adminToken');
          if (!token) {
            console.log('üîê [RESEARCH] No hay token almacenado');
            updateAdminElements(false);
            return false;
          }

          console.log('üîê [RESEARCH] Token encontrado, verificando...');
          const response = await fetch('http://localhost:8080/api/auth/verify', {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          if (response.ok) {
            const data = await response.json();
            const isAdmin = data.authenticated && data.isAdmin;
            console.log('üîê [RESEARCH] Verificaci√≥n exitosa:', { isAdmin, username: data.username });
            currentAdminStatus = isAdmin;
            updateAdminElements(isAdmin);
            return isAdmin;
          } else {
            console.log('üîê [RESEARCH] Token inv√°lido, status:', response.status);
            throw new Error('Token inv√°lido');
          }
        } catch (error) {
          console.error('‚ùå [RESEARCH] Error verificando token:', error);
          localStorage.removeItem('adminToken');
          currentAdminStatus = false;
          updateAdminElements(false);
          return false;
        }
      }
      
      // Actualizar elementos admin en la UI
      function updateAdminElements(isAdmin) {
        console.log('üé® [RESEARCH] Actualizando UI admin:', isAdmin);
        
        // Bot√≥n de agregar publicaci√≥n
        const addButton = document.getElementById('addButton');
        if (addButton) {
          if (isAdmin) {
            addButton.classList.remove('hidden');
            addButton.classList.add('flex');
          } else {
            addButton.classList.remove('flex');
            addButton.classList.add('hidden');
          }
        }
        
        // Botones de editar
        document.querySelectorAll('.edit-btn').forEach(btn => {
          if (isAdmin) {
            btn.classList.remove('hidden');
            btn.classList.add('flex');
          } else {
            btn.classList.remove('flex');
            btn.classList.add('hidden');
          }
        });
        
        // Botones de eliminar
        document.querySelectorAll('.delete-btn').forEach(btn => {
          if (isAdmin) {
            btn.classList.remove('hidden');
            btn.classList.add('block');
          } else {
            btn.classList.remove('block');
            btn.classList.add('hidden');
          }
        });
        
        console.log('‚úÖ [RESEARCH] UI actualizada correctamente');
      }
      
      // Escuchar cambios desde TopUtility
      window.addEventListener('adminStatusChanged', function(event) {
        const { isAdmin, source } = event.detail;
        console.log(`üîÑ [RESEARCH] Estado admin cambiado desde ${source}:`, isAdmin);
        currentAdminStatus = isAdmin;
        updateAdminElements(isAdmin);
      });
      
      // Inicializar estado admin al cargar la p√°gina
      checkAdminStatus();
      
      // Verificar estado cada 5 minutos para detectar tokens expirados
      setInterval(() => {
        console.log('‚è∞ [RESEARCH] Verificaci√≥n peri√≥dica del estado admin');
        checkAdminStatus();
      }, 300000);

      // Verificar al volver a la pesta√±a (detectar cambios en otras pesta√±as)
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          console.log('üëÅÔ∏è [RESEARCH] Tab visible, verificando admin status');
          checkAdminStatus();
        }
      });

      // Escuchar cambios en localStorage (para sincronizar entre pesta√±as)
      window.addEventListener('storage', (e) => {
        if (e.key === 'adminToken') {
          console.log('üîÑ [RESEARCH] Token cambiado en localStorage:', e.newValue ? 'Token a√±adido' : 'Token eliminado');
          if (e.newValue) {
            checkAdminStatus();
          } else {
            currentAdminStatus = false;
            updateAdminElements(false);
          }
        }
      });


      // ============= GESTI√ìN DE NOTIFICACIONES PENDIENTES =============

      setTimeout(() => {
        const pendingNotifications = JSON.parse(
          localStorage.getItem("pendingNotifications") || "[]",
        );
        if (pendingNotifications.length > 0) {
          console.log(
            `üìã [NEWS] Encontradas ${pendingNotifications.length} notificaciones pendientes en localStorage`,
          );

          if (
            window.notificationSystem &&
            window.notificationSystem.isInitialized
          ) {
            console.log(
              "üîÑ [NEWS] Forzando procesamiento de notificaciones pendientes",
            );

            pendingNotifications.forEach((notification, index) => {
              setTimeout(() => {
                window.notificationSystem.notify(
                  notification.message,
                  notification.type,
                  notification.duration,
                );
              }, index * 200);
            });

            localStorage.removeItem("pendingNotifications");
          }
        }
      }, 1000);

    });
  </script>
</BaseLayout>